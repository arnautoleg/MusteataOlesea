---
title: "CI"
author: "Oleg Arnaut"
date: "2023-10-04"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

library(tidyverse)
library(ggplot2)

#install.packages("BSDA")
library(BSDA)
#install.packages("binom")
library(binom)
#install.packages('ExactCIdiff')
library(ExactCIdiff)
#install.packages('epitools')
library(epitools)

```

# 1. Точечные оценки

## 1.1 Средний уровень биомаркера

Параметры эксперимента

```{r}
# Истинный средний уровень в генеральной совокупности:
m = 130

# Количество пациентов в выборке
n = 10

```

Как выглядит выборка?
```{r}

s <- round(rnorm(n,m,3),1)

print(s)

```

```{r}

m_est <- mean(s)

est_out <- paste0('Средний уровень биомаркера В ВЫБОРКЕ равен: ', round(m_est,3),  
                  '\nОшибка в оценке равна: ', round(m_est-m,3))

df <- data.frame(`Оценка среднего уровеня биомаркера` = m_est, check.names = FALSE)

plt <- ggplot(df, aes(x = `Оценка среднего уровеня биомаркера`, y = 0)) +
  geom_point() +
  scale_x_continuous(limits = c(120, 140)) +
  geom_vline(xintercept=m, linetype="dashed", color = "red") +
  theme_bw()

cat(est_out)
plt

```

Если повторить это исследование 30 раз?

```{r, echo=FALSE, fig.width=6, fig.height=5}

m_est_30 <- sapply(1:30, function(k){
  s <- round(rnorm(n,m,3),1)
  mean(s)
})

df <- data.frame(`Оценка среднего уровеня биомаркера` = m_est_30, 
                 `Номер эксперимента` = 1:30, check.names = FALSE)

plt <- ggplot(df, aes(x = `Оценка среднего уровеня биомаркера`, 
                      y = `Номер эксперимента`)) +
  geom_point() +
  scale_x_continuous(limits = c(120, 140)) +
  scale_y_continuous(breaks = 1:30) +
  geom_vline(xintercept=m, linetype="dashed", color = "red") +
  theme_bw()

plt

```

Поэкспериментируем с объемом выборки!

```{r, echo=FALSE, fig.width=6, fig.height=5}
n = 100

m_est_30 <- sapply(1:30, function(k){
  s <- round(rnorm(n,m,3),1)
  mean(s)
})

df <- data.frame(`Оценка среднего уровеня биомаркера` = m_est_30, 
                 `Номер эксперимента` = 1:30, check.names = FALSE)

plt <- ggplot(df, aes(x = `Оценка среднего уровеня биомаркера`, 
                      y = `Номер эксперимента`)) +
  geom_point() +
  scale_x_continuous(limits = c(120, 140)) +
  scale_y_continuous(breaks = 1:30) +
  geom_vline(xintercept=m, linetype="dashed", color = "red") +
  theme_bw()

plt

```

## 1.2 Описательные статистики для количественных переменных

```{r}

# Создаем набор данных
data <- c(15, 23, 17, 32, 19, 25, 21, 28, 14, 30)

# Среднее арифметическое (Mean)
mean_value <- mean(data)

# Медиана (Median)
median_value <- median(data)

# Мода (Mode) - для дискретных данных
mode_value <- as.numeric(names(sort(table(data), decreasing = TRUE)[1]))

# Минимум и максимум (Range)
min_value <- min(data)
max_value <- max(data)

# Стандартное отклонение (Standard Deviation)
sd_value <- sd(data)

# Дисперсия (Variance)
variance_value <- var(data)

# Размах (Range)
range_value <- max_value - min_value

# Квантили (Quantiles)
quantiles <- quantile(data, probs = c(0.25, 0.5, 0.75))

# Вывод результатов
cat("Среднее                :", mean_value, "\n")
cat("Медиана                :", median_value, "\n")
cat("Мода                   :", mode_value, "\n")
cat("Минимум                :", min_value, "\n")
cat("Максимум               :", max_value, "\n")
cat("Стандартное отклонение :", sd_value, "\n")
cat("Дисперсия              :", variance_value, "\n")
cat("Размах                 :", range_value, "\n")
cat("25-й квантиль          :", quantiles[1], "\n")
cat("50-й квантиль (медиана):", quantiles[2], "\n")
cat("75-й квантиль          :", quantiles[3], "\n")

```


## 1.3 Описательные статистики для категориальных переменных


```{r}

# Создаем набор данных для категориальной переменной (препараты)
data <- c("препарат A", "препарат B", "препарат A", "препарат C", "препарат B", "препарат A", "препарат A", "препарат B")

# Частота (Frequency)
frequency_table <- table(data)
cat("Частота каждой категории:\n")
print(frequency_table)
cat("\n")

# Относительная частота (Relative Frequency)
relative_frequency <- prop.table(frequency_table)
cat("Относительная частота каждой категории:\n")
print(relative_frequency)
cat("\n")

```


## 1.4 Описательные статистики для порядковых переменных


```{r}

# Создаем набор данных для порядковой переменной (степень гиперплазии)
data <- c("Низкий", "Средний", "Высокий", "Средний", "Средний", "Низкий", "Высокий", "Средний")

# Частота (Frequency)
frequency_table <- table(data)
cat("Частота каждой категории:\n")
print(frequency_table)
cat("\n")

# Относительная частота (Relative Frequency)
relative_frequency <- prop.table(frequency_table)
cat("Относительная частота каждой категории:\n")
print(relative_frequency)
cat("\n")

# Медиана (Median)
# Соответствие между порядковыми значениями и числами
ordered_values <- c("Низкий" = 1, "Средний" = 2, "Высокий" = 3)
numeric_data <- ordered_values[data]

median_value <- median(numeric_data)
cat("Медиана:", median_value, "\n")

```


## 1.5 Зачем нужна визуализация? 

```{r, fig.width=10, fig.height=5}


# Создаем 2x2 макет для графиков
par(mfrow=c(2, 2))

# Устанавливаем параметры нормального распределения
mean_normal <- 50
sd_normal <- 10
# Генерируем случайные данные для нормального распределения
data_normal <- rnorm(10000, mean = mean_normal, sd = sd_normal)

# График нормального распределения
hist(data_normal, breaks = 30, col = 'blue', main = 'Нормальное Распределение (μ=50)', xlab = 'Значение', ylab = 'Частота')

# Устанавливаем параметры равномерного распределения
min_uniform <- 44.5
max_uniform <- 55.5

# Генерируем случайные данные для равномерного распределения
data_uniform <- runif(10000, min = min_uniform, max = max_uniform)

# График равномерного распределения
hist(data_uniform, breaks = 30, col = 'green', main = 'Равномерное Распределение (μ=50)', xlab = 'Значение', ylab = 'Частота')

# Устанавливаем параметры бимодального распределения
mean1_bimodal <- 20
sd1_bimodal <- 10
mean2_bimodal <- 80
sd2_bimodal <- 10

# Генерируем случайные данные для бимодального распределения
data_bimodal <- c(rnorm(10000, mean = mean1_bimodal, sd = sd1_bimodal), rnorm(5000, mean = mean2_bimodal, sd = sd2_bimodal))

# График бимодального распределения
hist(data_bimodal, breaks = 30, col = 'red', main = 'Бимодальное Распределение (μ=50)', xlab = 'Значение', ylab = 'Частота')

# Генерируем данные для экспоненциального распределения с аналогичным средним и стандартным отклонением
mean_exp <- 50
sd_exp <- 10
lambda_exp <- 1 / mean_exp

data_exponential <- rexp(10000, rate = lambda_exp)

mean(data_exponential)

# График экспоненциального распределения
hist(data_exponential, breaks = 30, col = 'purple', main = 'Экспоненциальное Распределение (μ=50)', xlab = 'Значение', ylab = 'Частота')

# Вывод макета
par(mfrow=c(1, 1))


```

Достаточно ли точечной оценки?




# 2. Интервальные оценки


## 2.0 Интервальная оценка. Введение

```{r}

# Количество животных в выборке
n = 100

s <- round(rnorm(n,m,3),1)

print(s)

#? t.test

m_est <- t.test(s, conf.level = 0.95)$estimate
lb <- t.test(s)$conf.int[1]
ub <- t.test(s)$conf.int[2]

df <- data.frame(`Оценка среднего значения биомаркера` = m_est, 
                 lb = lb, ub = ub, check.names = FALSE)

plot(seq(m-3*3,m+3*3,0.01), dnorm(seq(m-3*3,m+3*3,0.01),m,3))

plt <- ggplot(df, aes(x = `Оценка среднего значения биомаркера`, y = 0)) +
  geom_point() +
  geom_errorbar(mapping = aes(xmin = lb, xmax = ub), size = 0.5, width = 0.2) +
  scale_x_continuous(limits = c(120, 140)) +
  scale_y_continuous(limits = c(-1, 1)) +
  geom_vline(xintercept=m, linetype="dashed", color = "red") +
  theme_bw()

plt

```


Доверяй, но проверяй!

```{r ie_22}
# Количество животных в выборке:
n = 3

confidence_level = 0.95

num_exp <- 100 

df_trial <- data.frame(
  center_ID = rep(1:num_exp, each = n),
  patient_ID = rep(1:n, num_exp),
  Hg_change = rnorm(n*num_exp, mean = m, sd = 3)
)

trial_results <- df_trial %>% 
  group_by(center_ID) %>% 
  do(broom::tidy(t.test(Hg_change ~ 1, conf.level = confidence_level, data = .))) %>% 
  dplyr::select(estimate, conf.low, conf.high) %>% 
  mutate(CI_width = conf.high - conf.low) %>% 
  mutate(out = ifelse((m < conf.high) & (m > conf.low), 'ok', 'missed'))

ggplot(trial_results, aes(y = center_ID)) +
  geom_errorbar(mapping = aes(xmin = conf.low, xmax = conf.high, color = out), size = 0.5) +
  geom_vline(xintercept=m, linetype="dashed", 
                color = "red", size=1) +
  scale_x_continuous(limits = c(120, 140)) +
  theme_bw() +
  theme(text = element_text(size = 20))  

print(table(trial_results$out))

```


Повторим много раз

```{r ie_23}

# Количество животных в выборке:
n = 3

confidence_level = 0.95

num_exp <- 1000

df_trial <- data.frame(
  center_ID = rep(1:num_exp, each = n),
  patient_ID = rep(1:n, num_exp),
  Hg_change = rnorm(n*num_exp, mean = m, sd = 3)
)

trial_results <- df_trial %>% 
  group_by(center_ID) %>% 
  do(broom::tidy(t.test(Hg_change ~ 1, conf.level = confidence_level, data = .))) %>% 
  dplyr::select(estimate, conf.low, conf.high) %>% 
  mutate(CI_width = conf.high - conf.low) %>% 
  mutate(out = ifelse((m < conf.high) & (m > conf.low), 'ok', 'missed'))

plot(seq(m-3*3,m+3*3,0.01), dnorm(seq(m-3*3,m+3*3,0.01),m,3))

print(table(trial_results$out))


```


А если исходное распределение другое?

```{r ie_23}
# Количество животных в выборке:
n = 3

confidence_level = 0.95

num_exp <- 1000

df_trial <- data.frame(
  center_ID = rep(1:num_exp, each = n),
  patient_ID = rep(1:n, num_exp),
  Hg_change = rexp(n*num_exp, 1/m)
)

trial_results <- df_trial %>% 
  group_by(center_ID) %>% 
  do(broom::tidy(t.test(Hg_change ~ 1, conf.level = confidence_level, data = .))) %>% 
  dplyr::select(estimate, conf.low, conf.high) %>% 
  mutate(CI_width = conf.high - conf.low) %>% 
  mutate(out = ifelse((m < conf.high) & (m > conf.low), 'ok', 'missed'))

plot(seq(0,5*m,0.01), dexp(seq(0,5*m,0.01),1/m))

print(table(trial_results$out))
```



## 2.1 Квантили

```{r}
# Загрузка необходимого пакета ggplot2
library(ggplot2)


a <- c(0:100)

cat(quantile(a, 0.025), 
    quantile(a, 0.975))

#?quantile


# Создание случайного вектора данных
data <- rnorm(1000000, mean = 0, sd = 1)
data_df <- data.frame(Value = data)


# Создание графика "ящик с усами" для данных
ggplot(data = data_df, aes(x = "", y = Value)) +
  geom_boxplot(fill = "lightblue", color = "blue") +
  labs(x = "", y = "Значение") +
  theme_minimal()


# Преобразование данных в data frame
data_df <- data.frame(Value = data)


quantile1 <- 0.05   
quantile2 <- 1  

# Вычисление q1 и q2 квантилей
q1 <- quantile(data, quantile1)
q2 <- quantile(data, quantile2)

# Создание графика плотности распределения с ggplot2
ggplot(data = data_df, aes(x = Value)) +
  geom_density(fill = "blue", alpha = 0.5) +
  geom_vline(xintercept = c(q1, q2), linetype = "dashed", color = "red") +
  annotate("text", x = q1-0.15, y = 0.3, label = sprintf("Q(%.1f)=%.2f", quantile1*100, q1), hjust = 1, angle = 90) +
  annotate("text", x = q2-0.15, y = 0.2, label = sprintf("Q(%.1f)=%.2f", quantile2*100, q2), hjust = 0, angle = 90) +
  labs(x = "Значение", y = "Плотность") +
  theme_minimal()



```
## 2.2 Доверительный интервал для среднего


### Асимптотический ДИ

```{r}

library(BSDA)

# Устанавливаем случайное зерно (для воспроизводимости результатов)
set.seed(123)

# Устанавливаем параметры нормального распределения
mean = 20   # Истинное среднее значение биомаркера 
sd = 3      # Истинное стандартное отклонение биомаркера

# Генерируем случайную выборку данных из нормального распределения
data <- rnorm(10, mean = mean, sd = sd)

# Уровень доверия
confidence_level <- 0.95

# Асимптотический доверительный интервал для среднего
z_test_result <- z.test(x=data, conf.level = confidence_level, sigma.x = sd(data), mu = mean)
ci_asymptotic <- z_test_result$conf.int
cat("Асимптотический ДИ (Z-interval) для среднего:", ci_asymptotic, "Ширина:", ci_asymptotic[2]-ci_asymptotic[1],"\n")




```


### Точный ДИ при неизвестной дисперсии (Теорема Фишера) 

```{r}

# Устанавливаем случайное зерно (для воспроизводимости результатов)
set.seed(123)

# Устанавливаем параметры нормального распределения
mean = 20   # Истинное среднее значение биомаркера 
sd = 3      # Истинное стандартное отклонение биомаркера

# Генерируем случайную выборку данных из нормального распределения
data <- rnorm(10, mean = mean, sd = sd)

# Уровень доверия
confidence_level <- 0.95

# Точный доверительный интервал для среднего (с неизвестной дисперсией)
ci_exact_unknown_var <- t.test(data, conf.level = confidence_level, var.equal = FALSE)$conf.int
cat("Точный ДИ (t-interval) для среднего (с неизвестной дисперсией):", ci_exact_unknown_var, "Ширина:", ci_exact_unknown_var[2]-ci_exact_unknown_var[1], "\n")


```

### Вместе

```{r}

cat("Асимптотический ДИ (Z-interval) для среднего                  :", ci_asymptotic, "Ширина:", ci_asymptotic[2]-ci_asymptotic[1],"\n")
cat("Точный ДИ (t-interval) для среднего (с неизвестной дисперсией):", ci_exact_unknown_var, "Ширина:", ci_exact_unknown_var[2]-ci_exact_unknown_var[1], "\n")


```

Какой из них выбрать?

### Доверительный интервал для среднего (симуляция)


#### Asymptotic Method (Z-interval) 

```{r}

# Устанавливаем случайное зерно (для воспроизводимости результатов)
set.seed(123)


# Истинные значения в популяции 
mean = 20   # Истинное среднее значение биомаркера 
sd = 3      # Истинное стандартное отклонение биомаркера

#Начальные параметры
confidence_level <- 0.95
sample_size <- 100 # число эксперментальных животных
num_simulations <- 1000


# Инициализируем переменную для подсчета количества "попаданий" истинного среднего 
asymptotic_captured <- 0

# Цикл для симуляции num_simulations раз
for (i in 1:num_simulations) {
  data <- rnorm(sample_size, mean = mean, sd = sd)
  
  # Рассчитываем доверительный интервалы 
  ci_asymptotic <- z.test(x=data, conf.level = confidence_level, sigma.x = sd(data), mu=mean)$conf.int
  

  
  # Проверяем, ловит ли доверительный интервал истинное значение среднего
  if (ci_asymptotic[1] <= mean && ci_asymptotic[2] >= mean) {
    asymptotic_captured <- asymptotic_captured + 1
  }
  
  
  
}


# Выводим результат
cat("Асимптотический ДИ - доля 'попаданий' истинного среднего    :", asymptotic_captured / num_simulations, "\n")


```



#### Сравнительная характеристика Asymptotic Method (Z-interval), Exact Method (t-interval) в случае нормального распределения (симуляция)

```{r}

# Устанавливаем случайное зерно (для воспроизводимости результатов)
set.seed(123)


# Истинные значения в популяции 
mean = 20   # Истинное среднее значение биомаркера 
sd = 3      # Истинное стандартное отклонение биомаркера

# Начальные параметры
confidence_level <- 0.95
sample_size <- 3 # число эксперментальных животных
num_simulations <- 1000



# Инициализируем переменную для подсчета количества "попаданий" истинного среднего 
asymptotic_captured <- 0
exact_t_captured <- 0

# Цикл для симуляции num_simulations раз
for (i in 1:num_simulations) {
  data <- rnorm(sample_size, mean = mean, sd = sd)
  
  # Рассчитываем доверительный интервал 
  ci_asymptotic <- z.test(x=data, conf.level = confidence_level, sigma.x = sd(data), mu=mean)$conf.int
  ci_exact_unknown_var <- t.test(data, conf.level = confidence_level, var.equal = FALSE)$conf.int
  
  # Проверяем, ловит ли доверительный интервал истинное значение среднего
  if (ci_asymptotic[1] <= mean && ci_asymptotic[2] >= mean) {
    asymptotic_captured <- asymptotic_captured + 1
  }
  
  if (ci_exact_unknown_var[1] <= mean && ci_exact_unknown_var[2] >= mean) {
    exact_t_captured <- exact_t_captured + 1
  }
  
}


# Выводим результат
cat("Асимптотический ДИ - доля 'попаданий' истинного среднего    :", asymptotic_captured / num_simulations, "\n")
cat("Точный ДИ (t-интервал) - доля 'попаданий' истинного среднего:", exact_t_captured / num_simulations, "\n")





```


#### Сравнительная характеристика Asymptotic Method (Z-interval), Exact Method (Z-intervalt-interval), Exact Method (t-interval) в случае экспоненциального распределения (симуляция)


```{r}

# Истинный средний уровень в генеральной совокупности
mean <- 10

# Вычисляем λ для экспоненциального распределения
lambda <- 1 / mean

# Генерируем случайные данные из экспоненциального распределения с указанным λ
data_exponential <- rexp(100, rate = lambda)

# Средний уровень и стандартное отклонение в ВЫБОРКЕ
actual_mean <- mean(data_exponential)
actual_sd <- sd(data_exponential)


cat("Средний уровень в ВЫБОРКЕ       :", actual_mean, "\n")
cat("Стандартное отклонение в ВЫБОРКЕ:", actual_sd, "\n")

hist(data_exponential)


```


```{r}

# Устанавливаем случайное зерно (для воспроизводимости результатов)
set.seed(123)

# Истинные значения в популяции 
mean = 20   # Истинное среднее значение биомаркера 
sd = 3      # Истинное стандартное отклонение биомаркера

# Начальные параметры
confidence_level <- 0.95
sample_size <- 3 # число эксперментальных животных
num_simulations <- 1000  



# Инициализируем переменную для подсчета количества "попаданий" истинного среднего 
asymptotic_captured <- 0
exact_t_captured <- 0

# Цикл для симуляции num_simulations раз
for (i in 1:num_simulations) {
  data <- rnorm(sample_size, mean = mean, sd = sd)
  data <- rexp(sample_size, rate = 1/mean)
  
  # Рассчитываем доверительный интервал 
  ci_asymptotic <- z.test(x=data, conf.level = confidence_level, sigma.x = sd(data), mu=mean)$conf.int
  ci_exact_unknown_var <- t.test(data, conf.level = confidence_level, var.equal = FALSE)$conf.int
  
  # Проверяем, ловит ли доверительный интервал истинное значение среднего
  if (ci_asymptotic[1] <= mean && ci_asymptotic[2] >= mean) {
    asymptotic_captured <- asymptotic_captured + 1
  }
  
  if (ci_exact_unknown_var[1] <= mean && ci_exact_unknown_var[2] >= mean) {
    exact_t_captured <- exact_t_captured + 1
  }
  
}


# Выводим результат
cat("Асимптотический ДИ - доля 'попаданий' истинного среднего    :", asymptotic_captured / num_simulations, "\n")
cat("Точный ДИ (t-интервал) - доля 'попаданий' истинного среднего:", exact_t_captured / num_simulations, "\n")




```


### От чего зависит ширина доверительного интервала?

```{r}

sample_size <- 100 # Количество животных, прошедших, терапию

b_improve <- 20   # Истинное среднее изменение уровня биомаркера (в ГЕНЕРАЛЬНОЙ СОВОКУПНОСТИ)

b_sd <- 6         # Разброс в улучшении биомаркера


df_trial <- data.frame(
  ID = 1:sample_size,
  b_change = rnorm(sample_size, mean = b_improve, sd = b_sd)
)

#t.test(df_trial$Hg_change)

trial_results <- df_trial %>% 
  t.test(b_change ~ 1, conf.level = 0.95, data = .) %>% 
  broom::tidy() %>% 
  dplyr::select(estimate, conf.low, conf.high) %>% 
  mutate(CI_width = conf.high - conf.low)

trial_results
  
# Что происходит с ДИ при изменении:
# - объема выборки?
# - стандартного отклонения?
# - уровня доверия?

```

## 2.3 Доверительный интервал для разницы средних

### 2.3.1 Доверительный интервал для разницы средних (независимые выборки)

```{r}

# Воспроизведение данных
set.seed(123)

# Пример данных для двух независимых выборок
mean1 = 20 # Истинная средняя биомаркера в группе терапии А
mean2 = 20 # Истинная средняя биомаркера в группе терапии А
sd = 3     # Истинное стандартное отклонение биомаркера в группах


# Формируем выборку
n1 = 10    # Количество животных в группе терапии А
n2 = 10    # Количество животных в группе терапии B

data1 <- rnorm(n1, mean = mean1, sd = sd) 
data2 <- rnorm(n2, mean = mean2, sd = sd)

# Уровень доверия
confidence_level <- 0.95

```


#### Асимптотический ДИ

```{r}

library(BSDA)


# Двухвыборочный Z-тест (Асимптотический ДИ)

z_test_result <- z.test(data1, data2, sigma.x = sd(data1), sigma.y = sd(data2))$conf.int

cat("Асимптотический доверительный интервал [", round(z_test_result[1], 4), ";", round(z_test_result[2], 4), "] Ширина:", round(z_test_result[2] - z_test_result[1], 4), "\n")


```


#### Примерный ДИ (Дисперсии не извеcтны и не равны)

Получить распределение для такой статистики не представляется возможным - нерешённая проблема статистики (проблема Беренца-Фишера - невозможно точно сравнить средние двух независимых выборок, дисперсии которых неизвестны) - распределение приближённое (распределение Уэлча, работает хорошо если количество наблюдений в группах совпадает или для выборки с большей дисперсией мы собираем больше наблюдений))


```{r}


t_result <- t.test(data1, data2, conf.level = 0.95, var.equal = FALSE)
ci_lower <- t_result$conf.int[1]
ci_upper <- t_result$conf.int[2]

cat("Доверительный интервал по Welch [", round(ci_lower, 4), ";", round(ci_upper, 4), "] Ширина:", round(ci_upper - ci_lower, 4), "\n")


```


#### Вместе

```{r}

cat("Асимптотический доверительный интервал [", round(z_test_result[1], 4), ";", round(z_test_result[2], 4), "] Ширина:", round(z_test_result[2] - z_test_result[1], 4), "\n")
cat("Доверительный интервал по Welch        [", round(ci_lower, 4), ";", round(ci_upper, 4), "] Ширина:", round(ci_upper - ci_lower, 4), "\n")



```



#### Доверительный интервал для разницы средних (симуляция)


##### Сравнительная характеристика (Asymptotic Confidence Interval, Confidence Interval by Welch) в случае нормального распределения (независимые группы)

```{r}

# Воспроизведение данных
set.seed(123)

# Пример данных для двух независимых выборок
mean1 = 20 # Истинная средняя биомаркера в группе терапии А
mean2 = 20 # Истинная средняя биомаркера в группе терапии А
sd = 3     # Истинное стандартное отклонение биомаркера в группах


# Формируем выборку
n1 = 3    # Количество животных в группе терапии А
n2 = 3    # Количество животных в группе терапии B

# Уровень доверия
confidence_level <- 0.95


# Инициализируем переменные для подсчета 'попаданий' истинной разницы
asymptotic_captured <- 0
approximate_welch_captured <- 0

# Цикл для симуляции 1000 раз
for (i in 1:1000) {
  # Генерируем случайные данные для двух выборок
  data1 <- rnorm(n1, mean = mean1, sd = sd)
  data2 <- rnorm(n2, mean = mean2, sd = sd)
  
  # Следующий блок кода для расчета каждого типа доверительного интервала
  
  # Асимптотический ДИ (двухвыборочный Z-тест)
  
  z_test_result <- z.test(data1, data2, sigma.x = sd(data1), sigma.y = sd(data2), conf.level = confidence_level)$conf.int

  if (z_test_result[1] <= 0 && z_test_result[2] >= 0) {
    asymptotic_captured <- asymptotic_captured + 1
  }

  
  # Примерный ДИ (Дисперсии не извеcтны и не равны)
  t_result <- t.test(data1, data2, conf.level = confidence_level, var.equal = FALSE)
  left_w <- t_result$conf.int[1]
  right_w <- t_result$conf.int[2]

  if (left_w <= 0 && right_w >= 0) {
    approximate_welch_captured <- approximate_welch_captured + 1
   }
}

# Выводим результаты
cat("Асимптотический ДИ - доля 'попаданий' истинной разницы                             :", asymptotic_captured / 1000, "\n")
cat("Примерный ДИ (Дисперсии не извеcтны и не равны) - доля 'попаданий' истинной разницы:", approximate_welch_captured / 1000, "\n")


```


##### Сравнительная характеристика (Asymptotic Confidence Interval, Confidence Interval by Welch) в случае экспоненциального распределения (независимые группы)



```{r}

# Воспроизведение данных
set.seed(123)

# Пример данных для двух независимых выборок
mean1 = 20 # Истинная средняя биомаркера в группе терапии А
mean2 = 20 # Истинная средняя биомаркера в группе терапии А
#sd = 3     # Истинное стандартное отклонение биомаркера в группах


# Формируем выборку
n1 = 3    # Количество животных в группе терапии А
n2 = 3    # Количество животных в группе терапии B

# Уровень доверия
confidence_level <- 0.95


# Инициализируем переменные для подсчета 'попаданий' истинной разницы
asymptotic_captured <- 0
approximate_welch_captured <- 0

# Цикл для симуляции 1000 раз
for (i in 1:1000) {
  # Генерируем случайные данные для двух выборок
  # data1 <- rnorm(n1, mean = mean1, sd = sd)
  # data2 <- rnorm(n2, mean = mean2, sd = sd)
  
  data1 <- rexp(n1, rate = 1/mean1)
  data2 <- rexp(n2, rate = 1/mean2)
  
  # Следующий блок кода для расчета каждого типа доверительного интервала
  
  # Асимптотический ДИ (двухвыборочный Z-тест)
  
  z_test_result <- z.test(data1, data2, sigma.x = sd(data1), sigma.y = sd(data2), conf.level = confidence_level)$conf.int

  if (z_test_result[1] <= 0 && z_test_result[2] >= 0) {
    asymptotic_captured <- asymptotic_captured + 1
  }

  
  # Примерный ДИ (Дисперсии не извеcтны и не равны)
  t_result <- t.test(data1, data2, conf.level = confidence_level, var.equal = FALSE)
  left_w <- t_result$conf.int[1]
  right_w <- t_result$conf.int[2]

  if (left_w <= 0 && right_w >= 0) {
    approximate_welch_captured <- approximate_welch_captured + 1
   }
}

# Выводим результаты
cat("Асимптотический ДИ - доля 'попаданий' истинной разницы                             :", asymptotic_captured / 1000, "\n")
cat("Примерный ДИ (Дисперсии не извеcтны и не равны) - доля 'попаданий' истинной разницы:", approximate_welch_captured / 1000, "\n")



```


### 2.3.2 Доверительный интервал для разницы средних (зависимые выборки)

#### Точный ДИ (Дисперсия неизвеcтна аналогично одинарной средней, статистика Стьюдента - распределение t)



## 2.4 Доверительный интервал для доли


### Асимптотический ДИ (Wald) и Точный ДИ (Clopper-Pearson) для доли

```{r}

# install.packages("binom")

library(binom)

#??binom

# Задайте размер выборки (n) и количество положительных наблюдений (x)
n <- 10 
x <- 8  

# Задайте уровень доверия (например, 95%)
alpha <- 0.05

# Рассчитайте доверительный интервал методом Клоппера-Пирсона
pearson_ci <- binom.confint(x, n, method = "exact", conf.level = 1 - alpha)

# Рассчитайте доверительный интервал методом Уолда
wald_ci <- binom.confint(x, n, method = "asymptotic", conf.level = 1 - alpha)

# Вывод результатов

cat("Асимптотический ДИ (Метод Wald) для доли   : [", round(wald_ci$lower, 4), ";", round(wald_ci$upper, 4), "] Ширина:", wald_ci$upper - wald_ci$lower,"\n")
cat("Точный ДИ (Метод Клоппера-Пирсона) для доли: [", round(pearson_ci$lower, 4), ";", round(pearson_ci$upper, 4), "] Ширина:", pearson_ci$upper - pearson_ci$lower,"\n")



```



### Метод Wald (симуляция) 


```{r}

#https://towardsdatascience.com/five-confidence-intervals-for-proportions-that-you-should-know-about-7ff5484c024f

# Воспроизведение данных
set.seed(123)

waldInterval <- function(x, n, conf.level = 0.95){
  p <- x/n
  sd <- sqrt(p*((1-p)/n))
  z <-  qnorm(c( (1 - conf.level)/2, 1 - (1-conf.level)/2)) # возвращает значения порогов, для соответствующего уровня доверия. Для 95% доверительного интервала это -1.96 и +1.96.
  ci <- p + z*sd
  return(ci)
}

numSamples <- 1000                # количество выборок для извлечения из популяции
numTrials <- 10                   # размер выборки (размер каждой выборки)
probs <- seq(0.1, 0.9, 0.1) # истинные пропорции в популяции. Для каждого значения в этом массиве будут построены 95% доверительные интервалы
coverage <- as.numeric()          # инициализация пустого вектора для сохранения вероятности покрытия для каждой из заданных пропорций

for (i in 1:length(probs)) {
  x <- rbinom(n = numSamples, size=numTrials, prob = probs[i]) # взятие n случайных выборок и получение числа успешных исходов в каждой из n выборок. Таким образом, x здесь будет иметь длину n.
  isCovered <- as.numeric() # вектор для обозначения, покрывается ли истинная пропорция популяции (probs[i]) в построенном интервале
  # так как у нас есть n различных x здесь, у нас будет n разных интервалов для каждого из них.
  
  for (j in 1:numSamples) {
    ci <- waldInterval(x = x[j], n = numTrials)
    isCovered[j] <- (ci[1] < probs[i]) & (probs[i] < ci[2]) # если истинная пропорция (probs[i]) покрывается в построенном доверительном интервале, то возвращается 1, иначе 0
  }
  
  coverage[i] <- mean(isCovered)*100 # сохранение вероятности покрытия для каждой из истинных пропорций. Идеально для 95% доверительного интервала это должно быть ближе к 95%
}

plot(probs, coverage, type='l', ylim = c(60,100), col='blue', lwd=2, frame.plot = FALSE, yaxt='n', main = 'Вероятность покрытия истинной пропорции (интервал Уальда)',
     xlab = 'Истинная пропорция (пропорция в популяции)', ylab = 'Вероятность покрытия (%) для 95% ДИ')
abline(h = 95, lty=3, col='maroon', lwd=2)
axis(side = 2, at=seq(60,100, 5))


```


### Метод Clopper — Pearson (симуляция)

```{r}

# Воспроизведение данных
set.seed(123)

numSamples <- 1000 # количество выборок, которые будут взяты из популяции
numTrials <- 10    # это размер каждой выборки

probs <- seq(0.1, 0.9, 0.1) # истинные пропорции в популяции. Для каждого значения в этом массиве мы построим 95% доверительные интервалы

coverage <- as.numeric() # инициализация пустого вектора для сохранения вероятности покрытия для каждой из пропорций, заданных выше

for (i in 1:length(probs)) {
  x <- rbinom(n = numSamples, size = numTrials, prob = probs[i]) # взятие n случайных выборок и получение числа успешных исходов в каждой из n выборок. Таким образом, x здесь будет иметь длину n.

  isCovered <- as.numeric() # булев вектор для обозначения, покрывается ли истинная пропорция в популяции (probs[i]) в построенных доверительных интервалах

  # так как у нас есть n различных x здесь, у нас будет n разных доверительных интервалов для каждого из них.

  for (j in 1:numSamples) {
    ci <- binom.test(x = x[j], n = numTrials)$conf # вычисление доверительного интервала Clopper–Pearson для каждой выборки и извлечение из него доверительного интервала

    isCovered[j] <- (ci[1] < probs[i]) & (probs[i] < ci[2]) # если истинная пропорция (probs[i]) покрывается в построенном доверительном интервале, то возвращается 1, иначе 0
  }

  coverage[i] <- mean(isCovered) * 100 # запись вероятности покрытия для каждой из истинных пропорций. Идеально для 95% доверительного интервала это должно быть ближе к 95%
}

plot(probs, coverage, type = 'l', ylim = c(75, 100), col = 'blue', lwd = 2, frame.plot = FALSE, yaxt = 'n', main = 'Вероятность покрытия истинной пропорции (интервал Clopper–Pearson)',
     xlab = 'Истинная пропорция (пропорция в популяции)', ylab = 'Вероятность покрытия (%) для 95% ДИ')

abline(h = 95, lty = 3, col = 'maroon', lwd = 2) # добавление горизонтальной пунктирной линии на уровне 95% для сравнения

axis(side = 2, at = seq(75, 100, 5)) # добавление оси координат на график






```



### Точность для ДИ Wald и ДИ Clopper-Pearson

```{r}

# Воспроизведение данных
# set.seed(123)

library(binom)

# Истинное значение доли осложнений
true_p <- 0.1 

# Размер выборки (количество экспериментальных животных) и количество повторений симуляции
n <- 10
num_simulations <- 1000

# Инициализация счетчиков для подсчета 'попаданий' истинного значения доли
wald_success_count <- 0
pearson_success_count <- 0

# Цикл для проведения симуляции
for (i in 1:num_simulations) {
  # Генерация случайной выборки из биномиального распределения
  sample_data <- rbinom(n, 1, true_p)
  
  # Рассчет доверительных интервалов
  wald_ci <- binom.confint(sum(sample_data), n, method = "asymptotic", conf.level = 0.95)
  pearson_ci <- binom.confint(sum(sample_data), n, method = "exact", conf.level = 0.95)
  
  # Проверка, ловит ли интервал истинное значение
  if (true_p >= wald_ci$lower && true_p <= wald_ci$upper) {
    wald_success_count <- wald_success_count + 1
  }
  if (true_p >= pearson_ci$lower && true_p <= pearson_ci$upper) {
    pearson_success_count <- pearson_success_count + 1
  }
}

# Подсчет процента 'попаданий' истинного значения доли
wald_success_rate <- wald_success_count / num_simulations * 100
pearson_success_rate <- pearson_success_count / num_simulations * 100

# Вывод результатов
cat("ДИ Wald 'поймал' истинное значение доли в            ", wald_success_rate, "% симуляций.\n")
cat("ДИ Clopper-Pearson 'поймал' истинное значение доли в ", pearson_success_rate, "% симуляций.\n")




```



## 2.5 Доверительный интервал для разницы долей

```{r, warning=FALSE}


# Пример данных
success_group1 <- 5 # абсолютная частота осложнений в эксперименте для животных из группы А
total_group1 <- 10  # количество животных в группе А
success_group2 <- 5 # абсолютная частота осложнений в эксперименте для животных из группы И
total_group2 <- 10  # количество животных в группе B


#?prop.test

# Вычисление асимптотического доверительного интервала для разницы долей (независимые выборки)
asym_ci <- prop.test(x = c(success_group1, success_group2), n = c(total_group1, total_group2), correct = FALSE)
asym_lower <- round(asym_ci$conf.int[1], 2)
asym_upper <- round(asym_ci$conf.int[2], 2)


# Вычисление точного доверительного интервала для разницы долей (независимые выборки)
# Установите и загрузите пакет ExactCIdiff
# install.packages('ExactCIdiff')
# library(ExactCIdiff)

# Точный доверительного интервала для разницы долей (независимые выборки)
exact_ci <- BinomCI(total_group1,total_group2,success_group1,success_group2, CItype='Two.sided')
exact_lower <- round(exact_ci$ExactCI[1], 2)
exact_upper <- round(exact_ci$ExactCI[2], 2)

# Вывод результатов в одной строке с указанием ширины интервалов и самих значений
cat("Асимптотический ДИ:", asym_lower, asym_upper, "Ширина:", asym_upper - asym_lower, "\n")
cat("Точный ДИ:        :", exact_lower, exact_upper, "Ширина:", exact_upper - exact_lower, "\n")



# Вычисление точного доверительного интервала для разницы долей (зависимые выборки)
#install.packages('ExactCIdiff')

library(ExactCIdiff)

n12 = 11
t = 9
n21 = 0


#n12 - количество субъектов в попарном исследовании, которые достигли успеха от лечения и неудачи от контроля.
#t   - количество субъектов в попарном исследовании, которые имеют одинаковые результаты от лечения и контроля, t = n11 + n22.
#n21 - количество субъектов в попарном исследовании, которые достигли успеха от контроля и неудачи от лечения.


result <- PairedCI(n12, t, n21, CItype = 'Two.sided')
cat("Точный доверительный интервал для разницы долей (зависимые выборки)", round(result$ExactCI[1], 2), round(result$ExactCI[2], 2), ", Ширина:", round(result$ExactCI[2] - result$ExactCI[1], 2), "\n")




```



### Точность ДИ для разницы долей

```{r, warning=FALSE}


# install.packages("ExactCIdiff")
library(ExactCIdiff)


# Задаем параметры генеральной совокупности
true_p1 <- 0.5  # относительная частота осложнений в эксперименте для животных из группы А
true_p2 <- 0.5  # относительная частота осложнений в эксперименте для животных из группы В
true_p <- true_p1 - true_p2

sample_size <- 10      # Размер выборки
n_simulations <- 1000  # Количество симуляций

# Инициализируем счетчики для оценки, сколько раз ДИ поймали истинное значение разницы долей
asymptotic_hits <- 0
exact_hits <- 0


#? rbinom

# Симулируем множество выборок и оцениваем ДИ
for (i in 1:n_simulations) {
  # Создаем случайные выборки с заданными параметрами
  sample1 <- rbinom(sample_size, size = 1, prob = true_p1)
  sample2 <- rbinom(sample_size, size = 1, prob = true_p2)
  
  
  # Вычисляем оценки долей
  success_group1 <- sum(sample1)
  total_group1 <- sample_size
  success_group2 <- sum(sample2)
  total_group2 <- sample_size
  
  # Вычисляем асимптотический ДИ
  asym_ci <- prop.test(x = c(success_group1, success_group2), n = c(total_group1, total_group2), alternative = "two.sided", correct = FALSE) 
  # Вычисляем точный ДИ
  #exact_ci <- BinomCI(total_group1, total_group2, success_group1, success_group2, CItype = "Two.sided")
  
  
  # Проверяем, ловят ли ДИ истинное значение
  if (true_p >= asym_ci$conf.int[1] && true_p <= asym_ci$conf.int[2]) {
    asymptotic_hits <- asymptotic_hits + 1
  }
  # if (true_p >= exact_ci$ExactCI[1] && true_p <= exact_ci$ExactCI[2]) {
  #   exact_hits <- exact_hits + 1
  # }
}

# Оцениваем, сколько раз ДИ поймали истинное значение
cat("Aсимптотический ДИ:", asymptotic_hits / n_simulations, "\n")
# cat("Точный ДИ          :", exact_hits / n_simulations, "\n")


```



## 2.6 Доверительный интервал для отношение шансов (OR) 


```{r, warning=FALSE}


library(epitools)

# Создайте 2x2 таблицу данных для анализа

table_data <- matrix(c(9, 1, 1, 9), nrow = 2)

# Добавьте имена строк и столбцов для ясности
rownames(table_data) <- c("Терапия A", "Терапия B")
colnames(table_data) <- c("Успех", "Неудача")

# Создайте 2x2 таблицу сопряженности
contingency_table <- as.table(table_data)


# 'fisher' для условной оценки максимального правдоподобия (Fisher)
result_fisher <- oddsratio.fisher(contingency_table)

# 'wald' для безусловной оценки максимального правдоподобия (Wald)
result_wald <- oddsratio.wald(contingency_table)


# Вывести результаты
cat("Отношение шансов (Fisher):", result_fisher$measure[2], "\n")
cat("Доверительный интервал (Fisher):", result_fisher$measure[4], result_fisher$measure[6], "\n")
cat("ширина Доверительного интервала (Fisher):", result_fisher$measure[6] - result_fisher$measure[4], "\n\n")

cat("Отношение шансов (Wald):", result_wald$measure[2], "\n")
cat("Доверительный интервал (Wald):", result_wald$measure[4], result_wald$measure[6], "\n")
cat("ширина Доверительного интервала (Wald):", result_wald$measure[6] - result_wald$measure[4], "\n\n")


```


## 2.7 Односторонние доверительные интервалы (исследования неменьшей эффективности или превосходства)

```{r}


sample_size <- 100 # Количество животных, прошедших, терапию

b_improve <- 20   # Истинное среднее изменение уровня биомаркера (в ГЕНЕРАЛЬНОЙ СОВОКУПНОСТИ)

b_sd <- 6         # Разброс в улучшении биомаркера

b_change <- rnorm(sample_size, 
                   mean = b_improve, 
                   sd = b_sd) # На сколько изменился биомаркер у животных?

# Меряем, на сколько изменился биомаркер после терапии:
result <- t.test(b_change, 
                 conf.level = 0.95)

cat('Двусторонний ДИ::', result$conf.int, "\n")

result <- t.test(b_change, 
                 conf.level = 0.95, 
                 alternative = 'greater')
cat('Односторонний ДИ:', result$conf.int, "\n")


# Попробуйте правосторонний ДИ:

result <- t.test(b_change, 
                 conf.level = 0.95, 
                 alternative = 'less')
cat('Односторонний ДИ:', result$conf.int, "\n")


```


## 2.8 Дополнительные материалы для самостоятельного разбора

### Точный ДИ для среднего при известной дисперсии 

```{r}

# Устанавливаем случайное зерно (для воспроизводимости результатов)
set.seed(123)

# Устанавливаем параметры нормального распределения
mean = 20   # Среднее значение
sd = 3      # Стандартное отклонение

# Генерируем случайную выборку данных из нормального распределения
data <- rnorm(10, mean = mean, sd = sd)

# Уровень доверия
confidence_level <- 0.95

# Вычисляем выборочное среднее
sample_mean <- mean(data)  # Выборочное среднее

# Размер выборки
sample_size <- length(data)  # Размер выборки

# Z-интервал (точный метод)
z_critical <- qnorm(1 - (1 - confidence_level) / 2)
margin_of_error <- z_critical * (sd / sqrt(sample_size))
ci_exact_z <- c(sample_mean - margin_of_error, sample_mean + margin_of_error)

cat("Точный метод (Z-интервал):", ci_exact_z, "Ширина:", ci_exact_z[2]-ci_exact_z[1], "\n")



```


### Сравнительная характеристика Asymptotic Method (Z-interval), Exact Method (Z-intervalt-interval), Exact Method (t-interval) в случае нормального распределения (симуляция)

```{r}

# Устанавливаем случайное зерно (для воспроизводимости результатов)
set.seed(123)


# Истинные значения в популяции 
mean = 20
sd = 3

# Начальные параметры
confidence_level <- 0.95
sample_size <- 100
num_simulations <- 1000

# Функция для создания доверительных интервалов
create_confidence_interval <- function(data, confidence_level, method) {
  sample_mean <- mean(data)
  sample_sd <- sd(data)
  sample_size <- length(data)
  
  if (method == "asymptotic") {
    z_critical <- qnorm(1 - (1 - confidence_level) / 2)
    margin_of_error <- z_critical * (sample_sd / sqrt(sample_size))
  } 
  
  # if (method == "exact_z") {
  #   z_critical <- qnorm(1 - (1 - confidence_level) / 2)
  #   margin_of_error <- z_critical * (sd / sqrt(sample_size))
  # } 
  
  if (method == "exact_t") {
    t_critical <- qt(1 - (1 - confidence_level) / 2, df = sample_size - 1)
    margin_of_error <- t_critical * (sample_sd / sqrt(sample_size))
  } 
  
  
  ci <- c(sample_mean - margin_of_error, sample_mean + margin_of_error)
  return(ci)
}

# Инициализируем переменные для подсчета количества 'попаданий' истинного среднего
asymptotic_captured <- 0
# exact_z_captured <- 0
exact_t_captured <- 0

# Цикл для симуляции num_simulations раз
for (i in 1:num_simulations) {
  data <- rnorm(sample_size, mean = mean, sd = sd)
  
  # Рассчитываем доверительные интервалы для каждого метода
  ci_asymptotic <- create_confidence_interval(data, confidence_level, "asymptotic")
  # ci_exact_z <- create_confidence_interval(data, confidence_level, "exact_z")
  ci_exact_t <- create_confidence_interval(data, confidence_level, "exact_t")
  
  # Проверяем, ловит ли доверительный интервал истинное значение среднего
  if (ci_asymptotic[1] <= mean && ci_asymptotic[2] >= mean) {
    asymptotic_captured <- asymptotic_captured + 1
  }
  
  # if (ci_exact_z[1] <= mean && ci_exact_z[2] >= mean) {
  #   exact_z_captured <- exact_z_captured + 1
  # }
  
  if (ci_exact_t[1] <= mean && ci_exact_t[2] >= mean) {
    exact_t_captured <- exact_t_captured + 1
  }
}

# Выводим результаты
cat("Асимптотический ДИ - доля 'попаданий' истинного среднего    :", asymptotic_captured / num_simulations, "\n")
# cat("Точный ДИ (Z-интервал) - доля 'попаданий' истинного среднего:", exact_z_captured / num_simulations, "\n")
cat("Точный ДИ (t-интервал) - доля 'попаданий' истинного среднего:", exact_t_captured / num_simulations, "\n")

```



### Точный ДИ для разницы средних (Дисперсии извеcтны, разность средних в точности имеет нормальное распределение, итоговая статистика также имеет нормальное z распределение)


```{r}


# Формируем 2 ВЫБОРКИ
x <- data1
y <- data2

# Рассчитываем разницу в средних значениях
diff <- mean(x) - mean(y)

# Размеры выборок
nx <- length(x)
ny <- length(y)

# Рассчитываем стандартное отклонение (SD) В данном случае это SD ПОПУЛЯЦИИ!!!
sd_x <- sd
sd_y <- sd

# Рассчитываем стандартную ошибку разницы средних значений
diff_sd <- sqrt(sd_x^2 / nx + sd_y^2 / ny)

# Рассчитываем 95% доверительный интервал
z <- qnorm(0.975)  # Для 95% доверительного интервала
left_t1 <- diff - z * diff_sd
right_t1 <- diff + z * diff_sd


# Выводим на экран доверительный интервал
cat("Точный доверительный интервал (известные дисперсии) [", round(left_t1, 4), ";", round(right_t1, 4), "] Ширина:", round(right_t1 - left_t1, 4), "\n")


# # Реализация в R
# 
# # Установите пакет "BSDA", если его еще нет (раскомментируйте и выполните эту строку)
# # install.packages("BSDA")
# 
# # Загрузите библиотеку "BSDA"
# library(BSDA)
# 
# # Выполните двухвыборочный Z-тест
# 
# z_test_result <- z.test(x, y, sigma.x = sd, sigma.y = sd)
# 
# # Выведите результат теста на экран
# print(z_test_result)




```


### Точный ДИ для разницы средних (Дисперсии неизвеcтны но равны, статистика Стьюдента - распределение t)


```{r}


# Формируем 2 ВЫБОРКИ
x <- data1
y <- data2

# Рассчитываем разницу в средних значениях
diff <- mean(x) - mean(y)

# Размеры выборок
nx <- length(x)
ny <- length(y)

# Рассчитываем стандартное отклонение (SD) 
sd_x <- sd(x)
sd_y <- sd(y)


# Степени свободы
df1 <- nx - 1
df2 <- ny - 1

# Рассчитываем стандартную ошибку разницы средних значений
diff_sd <- sqrt(sd_x^2 / nx + sd_y^2 / ny)

# Рассчитываем 95% доверительный интервал

t_critical <- qt(1 - (1 - confidence_level) / 2, df1 + df2)

left_t2 <- diff - t_critical * diff_sd
right_t2 <- diff + t_critical * diff_sd



# Выводим на экран доверительный интервал
cat("Точный доверительный интервал (неизвестные дисперсии) [", round(left_t2, 4), ";", round(right_t2, 4), "] Ширина:", round(right_t2 - left_t2, 4), "\n")


# # Реализация в R
# t_result <- t.test(x, y, conf.level = 0.95, var.equal = TRUE)
# ci_lower <- t_result$conf.int[1]
# ci_upper <- t_result$conf.int[2]
# 
# 
# # Выводим на экран доверительный интервал
# cat("Точный доверительный интервал (неизвестные дисперсии) [", round(ci_lower, 4), ";", round(ci_upper, 4), "] Ширина:", round(ci_lower - ci_upper, 4), "\n")


# library(car)
# # Perform Levene's test
# result <- leveneTest(c(x, y), as.factor(rep(c("Group1", "Group2"), each = nx)))
# 
# # Print the test result
# print(result)

```

### Сравнительная характеристика (Asymptotic Confidence Interval, Exact Confidence Interval with Known Variances, Exact Confidence Interval with Unknown Variances, Confidence Interval by Welch в случае нормального распределения (независимые группы) для разницы средних

```{r}

# Воспроизведение данных
set.seed(123)



# Пример данных для двух независимых выборок
mean1 <- 20
sd <- 3
mean2 <- 20
n1 <- 3
n2 <- 3

# Уровень доверия
confidence_level <- 0.95



# Инициализируем переменные для подсчета 'попаданий' истинной разницы
asymptotic_captured <- 0
exact_known_variance_captured <- 0
exact_unknown_variance_captured <- 0
approximate_welch_captured <- 0

# Цикл для симуляции 1000 раз
for (i in 1:1000) {
  # Генерируем случайные данные для двух выборок
  data1 <- rnorm(n1, mean = mean1, sd = sd)
  data2 <- rnorm(n2, mean = mean2, sd = sd)
  
  # Следующий блок кода для расчета каждого типа доверительного интервала
  
  # Асимптотический ДИ
  x <- data1
  y <- data2
  diff <- mean(x) - mean(y)
  nx <- length(x)
  ny <- length(y)
  sd_x <- sd(x)
  sd_y <- sd(y)
  diff_sd <- sqrt(sd_x^2 / nx + sd_y^2 / ny)
  z <- qnorm(0.975)
  left_a <- diff - z * diff_sd
  right_a <- diff + z * diff_sd
  if (left_a <= 0 && right_a >= 0) {
    asymptotic_captured <- asymptotic_captured + 1
  }
  
  # Точный ДИ с известной дисперсией
  x <- data1
  y <- data2
  diff <- mean(x) - mean(y)
  nx <- length(x)
  ny <- length(y)
  sd_x <- sd
  sd_y <- sd
  diff_sd <- sqrt(sd_x^2 / nx + sd_y^2 / ny)
  z <- qnorm(0.975)
  left_t1 <- diff - z * diff_sd
  right_t1 <- diff + z * diff_sd
  if (left_t1 <= 0 && right_t1 >= 0) {
    exact_known_variance_captured <- exact_known_variance_captured + 1
  }
  
  # Точный ДИ с неизвестной дисперсией
  x <- data1
  y <- data2
  diff <- mean(x) - mean(y)
  nx <- length(x)
  ny <- length(y)
  sd_x <- sd(x)
  sd_y <- sd(y)
  df1 <- n1 - 1
  df2 <- n2 - 1
  diff_sd <- sqrt(sd_x^2 / nx + sd_x^2 / ny)
  t_critical <- qt(1 - (1 - confidence_level) / 2, df1 + df2)
  left_t2 <- diff - t_critical * diff_sd
  right_t2 <- diff + t_critical * diff_sd
  if (left_t2 <= 0 && right_t2 >= 0) {
    exact_unknown_variance_captured <- exact_unknown_variance_captured + 1
  }
  
  # Примерный ДИ (Дисперсии не извеcтны и не равны)
  x <- data1
  y <- data2
  diff <- mean(x) - mean(y)
  nx <- length(x)
  ny <- length(y)
  sd_x <- sd(x)
  sd_y <- sd(y)
  diff_sd <- sqrt(sd_x^2 / nx + sd_y^2 / ny)
  numerator <- ((sd_x^2 / nx) + (sd_y^2 / n2))^2
  denominator <- (sd_x^4 / (nx^2 * (nx - 1))) + (sd_y^4 / (ny^2 * (ny - 1)))
  df <- numerator / denominator
  t_critical <- qt(1 - (1 - confidence_level) / 2, df)
  left_w_1 <- diff - t_critical * diff_sd
  right_w_1 <- diff + t_critical * diff_sd
  
  t_result <- t.test(x, y, conf.level = 0.95, var.equal = FALSE)
  left_w <- t_result$conf.int[1]
  right_w <- t_result$conf.int[2]
  
  if (left_w <= 0 && right_w >= 0) {
    approximate_welch_captured <- approximate_welch_captured + 1
  }
}

# Выводим результаты
cat("Асимптотический ДИ - доля 'попаданий' истинной разницы                             :", asymptotic_captured / 1000, "\n")
cat("Точный ДИ с известной дисперсией - доля 'попаданий' истинной разницы               :", exact_known_variance_captured / 1000, "\n")
cat("Точный ДИ с неизвестной дисперсией - доля 'попаданий' истинной разницы             :", exact_unknown_variance_captured / 1000, "\n")
cat("Примерный ДИ (Дисперсии не извеcтны и не равны) - доля 'попаданий' истинной разницы:", approximate_welch_captured / 1000, "\n")


```


### Сравнительная характеристика (Asymptotic Confidence Interval, Exact Confidence Interval with Known Variances, Exact Confidence Interval with Unknown Variances, Confidence Interval by Welch в случае экспоненциального распределения (независимые группы) для разницы средних




```{r}

# Воспроизведение данных
set.seed(123)

# Пример данных для двух независимых выборок
mean1 <- 20
#sd <- 3
mean2 <- 20
n1 <- 3
n2 <- 3


# Инициализируем переменные для подсчета 'попаданий' истинной разницы
asymptotic_captured <- 0
exact_known_variance_captured <- 0
exact_unknown_variance_captured <- 0
approximate_welch_captured <- 0

# Цикл для симуляции 1000 раз
for (i in 1:1000) {
  # Генерируем случайные данные для двух выборок
  #data1 <- rnorm(n1, mean = mean1, sd = sd)
  #data2 <- rnorm(n2, mean = mean2, sd = sd)
  data1 <- rexp(n1, rate = 1/mean1)
  data2 <- rexp(n2, rate = 1/mean2)
  
  # Следующий блок кода для расчета каждого типа доверительного интервала
  
  # Асимптотический ДИ
  x <- data1
  y <- data2
  diff <- mean(x) - mean(y)
  nx <- length(x)
  ny <- length(y)
  sd_x <- sd(x)
  sd_y <- sd(y)
  diff_sd <- sqrt(sd_x^2 / nx + sd_y^2 / ny)
  z <- qnorm(0.975)
  left_a <- diff - z * diff_sd
  right_a <- diff + z * diff_sd
  if (left_a <= 0 && right_a >= 0) {
    asymptotic_captured <- asymptotic_captured + 1
  }
  
  # Точный ДИ с известной дисперсией
  x <- data1
  y <- data2
  diff <- mean(x) - mean(y)
  nx <- length(x)
  ny <- length(y)

  sd_x <- round(sd_x, 0) # sd для такого распределения
  sd_y <- round(sd_y, 0) # sd для такого распределения
  diff_sd <- sqrt(sd_x^2 / nx + sd_y^2 / ny)
  z <- qnorm(0.975)
  left_t1 <- diff - z * diff_sd
  right_t1 <- diff + z * diff_sd
  if (left_t1 <= 0 && right_t1 >= 0) {
    exact_known_variance_captured <- exact_known_variance_captured + 1
  }
  
  # Точный ДИ с неизвестной дисперсией
  x <- data1
  y <- data2
  diff <- mean(x) - mean(y)
  nx <- length(x)
  ny <- length(y)
  sd_x <- sd(x)
  sd_y <- sd(y)
  
  df1 <- n1 - 1
  df2 <- n2 - 1
  diff_sd <- sqrt(sd_x^2 / nx + sd_y^2 / ny)
  t_critical <- qt(1 - (1 - confidence_level) / 2, df1 + df2)
  left_t2 <- diff - t_critical * diff_sd
  right_t2 <- diff + t_critical * diff_sd
  if (left_t2 <= 0 && right_t2 >= 0) {
    exact_unknown_variance_captured <- exact_unknown_variance_captured + 1
  }
  
  # Примерный ДИ (Дисперсии не извеcтны и не равны)
  x <- data1
  y <- data2
  diff <- mean(x) - mean(y)
  nx <- length(x)
  ny <- length(y)
  sd_x <- sd(x)
  sd_y <- sd(y)
  diff_sd <- sqrt(sd_x^2 / nx + sd_y^2 / ny)
  numerator <- ((sd_x^2 / nx) + (sd_y^2 / n2))^2
  denominator <- (sd_x^4 / (nx^2 * (nx - 1))) + (sd_y^4 / (ny^2 * (ny - 1)))
  df <- numerator / denominator
  t_critical <- qt(1 - (1 - confidence_level) / 2, df)
  left_w <- diff - t_critical * diff_sd
  right_w <- diff + t_critical * diff_sd
  
  t_result <- t.test(x, y, conf.level = 0.95, var.equal = FALSE)
  left_w <- t_result$conf.int[1]
  right_w <- t_result$conf.int[2]
  
  if (left_w <= 0 || right_w >= 0) {
    approximate_welch_captured <- approximate_welch_captured + 1
  }
}

# Выводим результаты
cat("Асимптотический ДИ - доля 'попаданий' истинной разницы                             :", asymptotic_captured / 1000, "\n")
cat("Точный ДИ с известной дисперсией - доля 'попаданий' истинной разницы               :", exact_known_variance_captured / 1000, "\n")
cat("Точный ДИ с неизвестной дисперсией - доля 'попаданий' истинной разницы             :", exact_unknown_variance_captured / 1000, "\n")
cat("Примерный ДИ (Дисперсии не извеcтны и не равны) - доля 'попаданий' истинной разницы:", approximate_welch_captured / 1000, "\n")


```


